// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include "HelloWorldService.h"
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TNonblockingServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
//#include <boost/smart_ptr/shared_ptr.hpp>
#include <thrift/protocol/TCompactProtocol.h>





using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

class HelloWorldServiceHandler : virtual public HelloWorldServiceIf {
 public:
  HelloWorldServiceHandler() {
    // Your initialization goes here
  }

  void sayHello(std::string& _return, const std::string& username) {
    // Your implementation goes here
    printf("sayHello\n");
    _return="hello,"+username;
  }

};








int main(int argc, char** argv) {

    //创建thrift server
    using namespace ::apache::thrift;

    using namespace ::apache::thrift::protocol;

    using namespace ::apache::thrift::transport;

    using namespace ::apache::thrift::server;

    using namespace::apache::thrift::concurrency;//zml

    using boost::shared_ptr;

    shared_ptr<HelloWorldServiceHandler> handler(new HelloWorldServiceHandler());

    shared_ptr<TProcessor> processor(new HelloWorldServiceProcessor(handler));

    shared_ptr<TProtocolFactory> protocolFactory(new TCompactProtocolFactory());
    shared_ptr<TTransportFactory> trasportfactory(new TFramedTransportFactory());
    shared_ptr<apache::thrift::transport::TNonblockingServerTransport> serverTransport=shared_ptr<apache::thrift::transport::TNonblockingServerTransport>(new TNonblockingServerSocket(9090));



  /*  shared_ptr<ThreadManager> threadManager = ThreadManager::newThreadManager();
   shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory> (new PosixThreadFactory());
    //PosixThreadFactory可以自定义（继承于ThreadFactory）
     threadManager->threadFactory(threadFactory);
    threadManager->start();
*/

  /*  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(10);//指定10个线程数
    shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
*/

   // TThreadPoolServer server(processor,serverTransport,trasportfactory,protocolFactory);//使用线程池
   // TNonblockingServer server(processor,protocolFactory,port);//使用线程池
    //TNonblockingServer server(processor,protocolFactory,port);//不使用线程池

   // server.serve();
  // TNonblockingServer server(processor, protocolFactory, serverTransport,shared_ptr<ThreadManager>());
  TNonblockingServer server(processor, serverTransport);
   // TNonblockingServer server(processor,trasportfactory,trasportfactory, protocolFactory, protocolFactory,serverTransport, threadManager);

    try{

        server.serve();

    }

    catch(TException e) {

        printf("Server.serve() failed\n");

        exit(-1);

    }

    return 0;

}

